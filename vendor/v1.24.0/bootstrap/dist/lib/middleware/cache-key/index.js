"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBatchChildKeys = exports.getCacheKey = exports.withCacheKey = void 0;
const tslib_1 = require("tslib");
const modules_1 = require("../../modules");
const util_1 = require("./util");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const selector_1 = require("../../modules/selector");
const util_2 = require("../../util");
const object_hash_1 = tslib_1.__importDefault(require("object-hash"));
const utils_1 = require("../ws/utils");
const baseInputParametersCachable = Object.keys(selector_1.baseInputParameters).filter((inputParam) => !util_1.excludableInternalAdapterRequestProperties.includes(inputParam));
const withCacheKey = (endpointSelector) => async (execute, context) => async (input) => {
    const endpoint = endpointSelector?.(input);
    if (!(endpoint && endpoint.inputParameters)) {
        // Fallback to legacy object hash cache key
        const cacheKey = util_1.hash(input, util_1.getHashOpts());
        const inputWithCacheKey = { ...input, debug: { ...input.debug, cacheKey } };
        return execute(inputWithCacheKey, context);
    }
    const inputParameterKeys = Object.keys(endpoint.inputParameters ?? {}).concat(baseInputParametersCachable);
    const validator = new modules_1.Validator(input, endpoint.inputParameters, {}, { shouldThrowError: false });
    const cacheKey = getCacheKey(validator.validated, inputParameterKeys);
    const batchCacheKey = endpoint.batchablePropertyPath
        ? getCacheKey(validator.validated, inputParameterKeys, endpoint.batchablePropertyPath)
        : undefined;
    const batchChildrenCacheKeys = batchCacheKey ? getBatchChildKeys(input, endpoint) : undefined;
    const inputWithCacheKey = {
        ...input,
        debug: { ...input.debug, cacheKey, batchCacheKey, batchChildrenCacheKeys },
    };
    return execute(inputWithCacheKey, context);
};
exports.withCacheKey = withCacheKey;
function getCacheKey(validatedData, inputParameterKeys, batchablePropertyPath) {
    let data = '';
    const inputParameterKeySet = new Set([...selector_1.baseInputParameterKeys, ...inputParameterKeys]);
    for (const key of inputParameterKeySet) {
        // We want the key to be consistent. So we omit batchable paths.
        // Otherwise it would change on every new child
        const isBatchableProperty = batchablePropertyPath && batchablePropertyPath.some(({ name }) => key === name);
        // Additionally, we ignore things like overrides that are not relevant to the DP request itself.
        const isExcludableProperty = util_1.excludableInternalAdapterRequestProperties.includes(key);
        if (isBatchableProperty || isExcludableProperty) {
            continue;
        }
        const value = validatedData.data[key];
        if (!value)
            continue;
        const valueString = util_2.isObject(value) ? object_hash_1.default(value) : JSON.stringify(value);
        data += valueString;
    }
    const shasum = crypto_1.default.createHash('sha1');
    shasum.update(data);
    return shasum.digest('base64');
}
exports.getCacheKey = getCacheKey;
function getBatchChildKeys(input, endpoint) {
    const children = [];
    utils_1.separateBatches(input, async (data) => {
        children.push(data);
    });
    return children.map((child) => {
        const inputParameterKeys = Object.keys(endpoint.inputParameters ?? {}).concat(baseInputParametersCachable);
        const validator = new modules_1.Validator(child, endpoint.inputParameters, {}, { shouldThrowError: false });
        return [getCacheKey(validator.validated, inputParameterKeys), child];
    });
}
exports.getBatchChildKeys = getBatchChildKeys;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL21pZGRsZXdhcmUvY2FjaGUta2V5L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSwyQ0FBeUM7QUFDekMsaUNBQXNGO0FBQ3RGLDREQUEyQjtBQUMzQixxREFBb0Y7QUFDcEYscUNBQXFDO0FBQ3JDLHNFQUFvQztBQUVwQyx1Q0FBNkM7QUFFN0MsTUFBTSwyQkFBMkIsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLDhCQUFtQixDQUFDLENBQUMsTUFBTSxDQUN6RSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQyxpREFBMEMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQ2pGLENBQUE7QUFFTSxNQUFNLFlBQVksR0FFUCxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQXFCLEVBQUUsRUFBRTtJQUNsRyxNQUFNLFFBQVEsR0FBRyxnQkFBZ0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBRTFDLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsZUFBZSxDQUFDLEVBQUU7UUFDM0MsMkNBQTJDO1FBQzNDLE1BQU0sUUFBUSxHQUFHLFdBQUksQ0FBQyxLQUFLLEVBQUUsa0JBQVcsRUFBRSxDQUFDLENBQUE7UUFDM0MsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFBO1FBQzNFLE9BQU8sT0FBTyxDQUFDLGlCQUFpQixFQUFFLE9BQU8sQ0FBQyxDQUFBO0tBQzNDO0lBRUQsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDLENB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NUIsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUMzRSwyQkFBMkIsQ0FDNUIsQ0FBQTtRQUNELE1BQU0sU0FBUyxHQUFHLElBQUksbUJBQVMsQ0FDN0IsS0FBSyxFQUNMLFFBQVEsQ0FBQyxlQUFlLEVBQ3hCLEVBQUUsRUFDRixFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxDQUM1QixDQUFBO1FBQ0QsT0FBTyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLGtCQUFrQixDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7SUFDdEUsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDO0FBckJELDhDQXFCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTWlkZGxld2FyZSwgQWRhcHRlclJlcXVlc3QsIENvbmZpZywgQVBJRW5kcG9pbnQgfSBmcm9tICdAY2hhaW5saW5rL3R5cGVzJ1xuaW1wb3J0IHsgVmFsaWRhdG9yIH0gZnJvbSAnLi4vLi4vbW9kdWxlcydcbmltcG9ydCB7IGdldEhhc2hPcHRzLCBoYXNoLCBleGNsdWRhYmxlSW50ZXJuYWxBZGFwdGVyUmVxdWVzdFByb3BlcnRpZXMgfSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0bydcbmltcG9ydCB7IGJhc2VJbnB1dFBhcmFtZXRlcktleXMsIGJhc2VJbnB1dFBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9tb2R1bGVzL3NlbGVjdG9yJ1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuLi8uLi91dGlsJ1xuaW1wb3J0IG9iamVjdEhhc2ggZnJvbSAnb2JqZWN0LWhhc2gnXG5pbXBvcnQgeyBCYXRjaGFibGVQcm9wZXJ0eSB9IGZyb20gJy4uL2NhY2hlLXdhcm1lci9yZWR1Y2VyJ1xuaW1wb3J0IHsgc2VwYXJhdGVCYXRjaGVzIH0gZnJvbSAnLi4vd3MvdXRpbHMnXG5cbmNvbnN0IGJhc2VJbnB1dFBhcmFtZXRlcnNDYWNoYWJsZSA9IE9iamVjdC5rZXlzKGJhc2VJbnB1dFBhcmFtZXRlcnMpLmZpbHRlcihcbiAgKGlucHV0UGFyYW0pID0+ICFleGNsdWRhYmxlSW50ZXJuYWxBZGFwdGVyUmVxdWVzdFByb3BlcnRpZXMuaW5jbHVkZXMoaW5wdXRQYXJhbSksXG4pXG5cbmV4cG9ydCBjb25zdCB3aXRoQ2FjaGVLZXk6IDxDIGV4dGVuZHMgQ29uZmlnPihcbiAgZW5kcG9pbnRTZWxlY3Rvcj86IChyZXF1ZXN0OiBBZGFwdGVyUmVxdWVzdCkgPT4gQVBJRW5kcG9pbnQ8Qz4sXG4pID0+IE1pZGRsZXdhcmUgPSAoZW5kcG9pbnRTZWxlY3RvcikgPT4gYXN5bmMgKGV4ZWN1dGUsIGNvbnRleHQpID0+IGFzeW5jIChpbnB1dDogQWRhcHRlclJlcXVlc3QpID0+IHtcbiAgY29uc3QgZW5kcG9pbnQgPSBlbmRwb2ludFNlbGVjdG9yPy4oaW5wdXQpXG5cbiAgaWYgKCEoZW5kcG9pbnQgJiYgZW5kcG9pbnQuaW5wdXRQYXJhbWV0ZXJzKSkge1xuICAgIC8vIEZhbGxiYWNrIHRvIGxlZ2FjeSBvYmplY3QgaGFzaCBjYWNoZSBrZXlcbiAgICBjb25zdCBjYWNoZUtleSA9IGhhc2goaW5wdXQsIGdldEhhc2hPcHRzKCkpXG4gICAgY29uc3QgaW5wdXRXaXRoQ2FjaGVLZXkgPSB7IC4uLmlucHV0LCBkZWJ1ZzogeyAuLi5pbnB1dC5kZWJ1ZywgY2FjaGVLZXkgfSB9XG4gICAgcmV0dXJuIGV4ZWN1dGUoaW5wdXRXaXRoQ2FjaGVLZXksIGNvbnRleHQpXG4gIH1cblxuICBjb25zdCBpbnB1dFBhcmFtZXRlcktleXMgPSBPYmplY3Qua2V5cyhlbmRwb2ludC5pbnB1dFBhcmFtZXRlcnMgPz8ge30pLmNvbmNhdChcbiAgICBiYXNlSW5wdXRQYXJhbWV0ZXJzQ2FjaGFibGUsXG4gIClcbiAgY29uc3QgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihpbnB1dCwgZW5kcG9pbnQuaW5wdXRQYXJhbWV0ZXJzLCB7fSwgeyBzaG91bGRUaHJvd0Vycm9yOiBmYWxzZSB9KVxuXG4gIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkodmFsaWRhdG9yLnZhbGlkYXRlZCwgaW5wdXRQYXJhbWV0ZXJLZXlzKVxuXG4gIGNvbnN0IGJhdGNoQ2FjaGVLZXkgPSBlbmRwb2ludC5iYXRjaGFibGVQcm9wZXJ0eVBhdGhcbiAgICA/IGdldENhY2hlS2V5KHZhbGlkYXRvci52YWxpZGF0ZWQsIGlucHV0UGFyYW1ldGVyS2V5cywgZW5kcG9pbnQuYmF0Y2hhYmxlUHJvcGVydHlQYXRoKVxuICAgIDogdW5kZWZpbmVkXG5cbiAgY29uc3QgYmF0Y2hDaGlsZHJlbkNhY2hlS2V5cyA9IGJhdGNoQ2FjaGVLZXkgPyBnZXRCYXRjaENoaWxkS2V5cyhpbnB1dCwgZW5kcG9pbnQpIDogdW5kZWZpbmVkXG5cbiAgY29uc3QgaW5wdXRXaXRoQ2FjaGVLZXkgPSB7XG4gICAgLi4uaW5wdXQsXG4gICAgZGVidWc6IHsgLi4uaW5wdXQuZGVidWcsIGNhY2hlS2V5LCBiYXRjaENhY2hlS2V5LCBiYXRjaENoaWxkcmVuQ2FjaGVLZXlzIH0sXG4gIH1cbiAgcmV0dXJuIGV4ZWN1dGUoaW5wdXRXaXRoQ2FjaGVLZXksIGNvbnRleHQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZUtleShcbiAgdmFsaWRhdGVkRGF0YTogVmFsaWRhdG9yWyd2YWxpZGF0ZWQnXSxcbiAgaW5wdXRQYXJhbWV0ZXJLZXlzOiBzdHJpbmdbXSxcbiAgYmF0Y2hhYmxlUHJvcGVydHlQYXRoPzogQmF0Y2hhYmxlUHJvcGVydHlbXSxcbik6IHN0cmluZyB7XG4gIGxldCBkYXRhID0gJydcblxuICBjb25zdCBpbnB1dFBhcmFtZXRlcktleVNldCA9IG5ldyBTZXQoWy4uLmJhc2VJbnB1dFBhcmFtZXRlcktleXMsIC4uLmlucHV0UGFyYW1ldGVyS2V5c10pXG5cbiAgZm9yIChjb25zdCBrZXkgb2YgaW5wdXRQYXJhbWV0ZXJLZXlTZXQpIHtcbiAgICAvLyBXZSB3YW50IHRoZSBrZXkgdG8gYmUgY29uc2lzdGVudC4gU28gd2Ugb21pdCBiYXRjaGFibGUgcGF0aHMuXG4gICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGNoYW5nZSBvbiBldmVyeSBuZXcgY2hpbGRcbiAgICBjb25zdCBpc0JhdGNoYWJsZVByb3BlcnR5ID1cbiAgICAgIGJhdGNoYWJsZVByb3BlcnR5UGF0aCAmJiBiYXRjaGFibGVQcm9wZXJ0eVBhdGguc29tZSgoeyBuYW1lIH0pID0+IGtleSA9PT0gbmFtZSlcbiAgICAvLyBBZGRpdGlvbmFsbHksIHdlIGlnbm9yZSB0aGluZ3MgbGlrZSBvdmVycmlkZXMgdGhhdCBhcmUgbm90IHJlbGV2YW50IHRvIHRoZSBEUCByZXF1ZXN0IGl0c2VsZi5cbiAgICBjb25zdCBpc0V4Y2x1ZGFibGVQcm9wZXJ0eSA9IGV4Y2x1ZGFibGVJbnRlcm5hbEFkYXB0ZXJSZXF1ZXN0UHJvcGVydGllcy5pbmNsdWRlcyhrZXkpXG4gICAgaWYgKGlzQmF0Y2hhYmxlUHJvcGVydHkgfHwgaXNFeGNsdWRhYmxlUHJvcGVydHkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0ZWREYXRhLmRhdGFba2V5XVxuICAgIGlmICghdmFsdWUpIGNvbnRpbnVlXG4gICAgY29uc3QgdmFsdWVTdHJpbmcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RIYXNoKHZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIGRhdGEgKz0gdmFsdWVTdHJpbmdcbiAgfVxuXG4gIGNvbnN0IHNoYXN1bSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJylcbiAgc2hhc3VtLnVwZGF0ZShkYXRhKVxuICByZXR1cm4gc2hhc3VtLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhdGNoQ2hpbGRLZXlzPEMgZXh0ZW5kcyBDb25maWc+KFxuICBpbnB1dDogQWRhcHRlclJlcXVlc3QsXG4gIGVuZHBvaW50OiBBUElFbmRwb2ludDxDPixcbik6IFtzdHJpbmcsIEFkYXB0ZXJSZXF1ZXN0XVtdIHtcbiAgY29uc3QgY2hpbGRyZW46IEFkYXB0ZXJSZXF1ZXN0W10gPSBbXVxuICBzZXBhcmF0ZUJhdGNoZXMoaW5wdXQsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgY2hpbGRyZW4ucHVzaChkYXRhKVxuICB9KVxuXG4gIHJldHVybiBjaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgaW5wdXRQYXJhbWV0ZXJLZXlzID0gT2JqZWN0LmtleXMoZW5kcG9pbnQuaW5wdXRQYXJhbWV0ZXJzID8/IHt9KS5jb25jYXQoXG4gICAgICBiYXNlSW5wdXRQYXJhbWV0ZXJzQ2FjaGFibGUsXG4gICAgKVxuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IoXG4gICAgICBjaGlsZCxcbiAgICAgIGVuZHBvaW50LmlucHV0UGFyYW1ldGVycyxcbiAgICAgIHt9LFxuICAgICAgeyBzaG91bGRUaHJvd0Vycm9yOiBmYWxzZSB9LFxuICAgIClcbiAgICByZXR1cm4gW2dldENhY2hlS2V5KHZhbGlkYXRvci52YWxpZGF0ZWQsIGlucHV0UGFyYW1ldGVyS2V5cyksIGNoaWxkXVxuICB9KVxufVxuIl19